ft_check_error_2 (data=0x5555555796f0, str=0x7fffffffdbf8) at source/./exec/./check_command.c:132
132		i = 0;
(gdb) n
133		if (has_slash(data->command[0]) == 1)
(gdb) n
137			tmpstr = getenv_but_better(data);
(gdb) n
138			if (!tmpstr)
(gdb) n
145				tmp = ft_split(tmpstr, ':');
(gdb) n
146			if (!tmp)
(gdb) n
152			while (tmp[i])
(gdb) n
154				if (strcpr(tmp, &(*str), i, data) == -1)
(gdb) n
156				j = check_error_tool(data , *(&str));
(gdb) n
157				if (j == 1 || j == -1)
(gdb) n
159				i++;
(gdb) n
160				free(*str);
(gdb) n
152			while (tmp[i])
(gdb) n
154				if (strcpr(tmp, &(*str), i, data) == -1)
(gdb) n
156				j = check_error_tool(data , *(&str));
(gdb) n
157				if (j == 1 || j == -1)
(gdb) n
159				i++;
(gdb) n
160				free(*str);
(gdb) n
152			while (tmp[i])
(gdb) n
154				if (strcpr(tmp, &(*str), i, data) == -1)
(gdb) n
156				j = check_error_tool(data , *(&str));
(gdb) n
157				if (j == 1 || j == -1)
(gdb) n
159				i++;
(gdb) n
160				free(*str);
(gdb) n
152			while (tmp[i])
(gdb) n
154				if (strcpr(tmp, &(*str), i, data) == -1)
(gdb) n
156				j = check_error_tool(data , *(&str));
(gdb) n
157				if (j == 1 || j == -1)
(gdb) n
159				i++;
(gdb) n
160				free(*str);
(gdb) n
152			while (tmp[i])
(gdb) n
154				if (strcpr(tmp, &(*str), i, data) == -1)
(gdb) n
156				j = check_error_tool(data , *(&str));
(gdb) n
157				if (j == 1 || j == -1)
(gdb) n
159				i++;
(gdb) n
160				free(*str);
(gdb) n
152			while (tmp[i])
(gdb) n
154				if (strcpr(tmp, &(*str), i, data) == -1)
(gdb) n
156				j = check_error_tool(data , *(&str));
(gdb) n
157				if (j == 1 || j == -1)
(gdb) n
159				i++;
(gdb) n
160				free(*str);
(gdb) n
152			while (tmp[i])
(gdb) n
154				if (strcpr(tmp, &(*str), i, data) == -1)
(gdb) n
156				j = check_error_tool(data , *(&str));
(gdb) 
n157				if (j == 1 || j == -1)
(gdb) n
158					return (free(tmp), j);
(gdb) n
176	}
(gdb) n
ft_check_error (data=0x5555555796f0, str=0x7fffffffdbf8) at source/./exec/./check_command.c:187
187	}
(gdb) n
ft_command (data=0x5555555796f0) at source/./exec/command.c:173
173				if (i == -1)
(gdb) n
175				if (i != 0)
(gdb) n
177					pid[y] = fork();
(gdb) n
[Detaching after fork from child process 234005]
178					if (pid[y] == 0 && i == 1)
(gdb) x : 4
j : 3
fd[0] : 4
fd[1] : 3
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: gfranque <gfranque@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/01/28 12:52:13 by gfranque          #+#    #+#              #
#    Updated: 2023/05/10 12:01:21 by gfranque         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

NAME = minishell

SRC = ./main.c ./bultins/echo.c ./bultins/cd.c ./bultins/pwd.c ./parsing/controll.c\
		./bultins/env.c ./bultins/unset.c ./bultins/export.c ./bultins/export_utils.c\
		./exec/command.c ./exec/redirection.c error.c ./exec/./check_command.c\
		./Parsing/datahandling.c ./Parsing/dataprocessing.c ./Parsing/dataprocessing2.c\
		./Parsing/textprocessing.c ./Parsing/charstuff.c ./Parsing/lexing1.c\
		./Parsing/lexing2.c ./Parsing/lexing3.c ./Parsing/tokenhandling.c

PRINTF = ./source/Printf/libftprintf.a

INCLUDES = -I ./include/

LIBFTINC = -I ./source/Libft/

PRINTFINC = -I ./source/Printf

LIBFT = ./source/Libft/libft.a

SRC_DIR = source

OBJ_DIR = objet

MORE_DIR = $(OBJ_DIR)/bultins $(OBJ_DIR)/parsing $(OBJ_DIR)/exec $(OBJ_DIR)/Parsing

SRCS = $(SRC:%=$(SRC_DIR)/%)

OBJS = $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

GCC = gcc

FLAGS = -Wall -Wextra -Werror -g3

READLINE = -lreadline

RM = rm -rf

MKDIR = mkdir -p

###############
### COLORS	###
###############

COLORGREEN = @echo -n "\033[92m"

COLORCYAN = @echo -n "\033[36m"

COLORYELLOW = @echo -n "\033[33m"

UNCOLOR = @echo -n "\033[0m"

RESET = \033[0m

WHITE = \033[37m

ORANGE = \033[41m

BLACK = \033[100m

BACKCYAN = \033[46m

BACKYELLOW = \033[43m

BOLDCYAN = \033[1;34m

BOLDBLUE = \033[1;36m

###############
###	RULES	###
###############

all:	$(NAME)

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@$(MKDIR) $(OBJ_DIR)
	@$(MKDIR) $(MORE_DIR)
	$(COLORCYAN)
	$(GCC) $(FLAGS) $(LIBFTINC) $(PRINTFINC) $(INCLUDES) -c $< -o $@
	$(UNCOLOR)

$(NAME):	$(OBJS)
	@echo "$(BOLDCYAN) Minishell $(RESET)"
	$(COLORGREEN)
	make -C ./source/Libft
	make -C ./source/Printf
	$(UNCOLOR)
	$(COLORCYAN)
	$(GCC) $(FLAGS) -o $(NAME) $(LIBFTINC) $(PRINTFINC) $(INCLUDES) $(OBJS) $(LIBFT) $(PRINTF) $(READLINE)
	$(UNCOLOR)
	@echo "$(BOLDCYAN) Compilation completed $(RESET)"

clean:
	$(COLORYELLOW)
	$(RM) $(OBJ_DIR)
	$(UNCOLOR)
	@echo "$(BACKYELLOW)$(WHITE) Clean done $(RESET)"

fclean:	clean
	$(COLORYELLOW)
	@make fclean -C ./source/Libft
	@make fclean -C ./source/Printf
	$(UNCOLOR)
	$(COLORYELLOW)
	$(RM) $(NAME) $(NAMEBONUS)
	$(UNCOLOR)
	@echo "$(BACKYELLOW)$(WHITE) Fclean done $(RESET)"

re: fclean all

m: all clean

.PHONY: all clean fclean re m bonus

192					else if (pid[y] < 0)
(gdb) n
194					if (data->next)
(gdb) n
197					free(str);
(gdb) n
198					y++;
(gdb) n
200				close(data->fd[1]);
(gdb) n
203			if (data->next && i == 0)
(gdb) n
205			data = data->next;
(gdb) n
157		while (data && i > -1)
(gdb) 
207		if (pid[0] != -1)
(gdb) n
208			ft_parent(pid, y);
(gdb) n
y 1
 pid 0
209		free(pid);
(gdb) n
210		redirect(x, j);
(gdb) n
211		close (x);
(gdb) n
212		close (j);
(gdb) n
213		return (i);
(gdb) n
214	}
(gdb) n
road (data=0x5555555796f0) at source/./parsing/controll.c:43
43		if (ft_command(data) == -1)
(gdb) n
45		while (data)
(gdb) n
47			close(data->fd[0]);
(gdb) n
48			data = data->next;
(gdb) n
45		while (data)
(gdb) n
51		return (1);
(gdb) n
52	}
(gdb) n
ft_lexing (str=0x555555579e30 "cat Makefile", begin=0x555555579d50, data=0x5555555796f0) at source/./Parsing/dataprocessing.c:95
95	}
(gdb) n
main (ac=1, av=0x7fffffffde08, envp=0x7fffffffde18) at source/./main.c:78
78				add_history(str);
(gdb) n
79				free(str);
(gdb) n
80				ft_dataclear(data);
(gdb) n
62		while (i != -1)
(gdb) n
64			signal(SIGINT, &action);
(gdb) n
65			str = readline("\033[1;36mminishell> \033[0m");
(gdb) n
minishell> 
67			if (!str)
(gdb) n
69				write(1, "out\n", 4);
(gdb) n
out
70				i = -1;
(gdb) n
62		while (i != -1)
(gdb) n
83		rl_clear_history();
(gdb) n
84		return (g_exitcode);
(gdb) n
85	}
